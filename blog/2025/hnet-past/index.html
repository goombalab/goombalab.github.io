<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> H-Nets - the Past | Goomba Lab </title> <meta name="author" content="Goomba AI Lab"> <meta name="description" content="Homepage of the Goomba AI Lab @ CMU MLD. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/goomba_light.png?68e59a389531e710f3507b5f12827027"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://goombalab.github.io/blog/2025/hnet-past/"> <script src="/assets/js/theme.js?daf0da4e15ae2df6b4045ab97d680f8d"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "H-Nets - the Past",
            "description": "",
            "published": "July 10, 2025",
            "authors": [
              
              {
                "author": "Albert Gu",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "CMU, Cartesia AI",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Goomba Lab <img src="/assets/img/goomba_transparent.png" width="30" height="30"> </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">people </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>H-Nets - the Past</h1> <p></p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#hierarchy-is-everywhere">Hierarchy is Everywhere</a> </div> <div> <a href="#hierarchical-rnns">Hierarchical RNNs</a> </div> <div> <a href="#s4-and-sashimi">S4 and SaShiMi</a> </div> <ul> <li> <a href="#autoregressive-u-nets-for-image-modeling">Autoregressive U-Nets for image modeling</a> </li> <li> <a href="#u-nets-don-39-t-work-for-language">U-Nets don't work for language</a> </li> <li> <a href="#but-they-work-great-for-audio">But they work great for audio!</a> </li> </ul> <div> <a href="#a-differentiable-chunking-mechanism">A Differentiable Chunking Mechanism?</a> </div> <ul> <li> <a href="#attention-as-a-primitive">Attention as a primitive</a> </li> <li> <a href="#chunking-as-a-primitive">Chunking as a primitive</a> </li> <li> <a href="#tokenization-as-a-case-study">Tokenization as a case study</a> </li> <li> <a href="#stuck">Stuck.</a> </li> </ul> <div> <a href="#information-based-chunking">Information-based Chunking</a> </div> <ul> <li> <a href="#total-information-content-as-a-chunking-strategy">Total information content as a chunking strategy</a> </li> <li> <a href="#the-project-begins">The project begins</a> </li> </ul> <div> <a href="#differentiable-selection-with-modern-techniques">Differentiable Selection with Modern Techniques</a> </div> <div> <a href="#discovering-prior-and-concurrent-works">Discovering Prior and Concurrent Works</a> </div> <ul> <li> <a href="#hourglass-and-dynamic-pooling-transformer">Hourglass and Dynamic Pooling Transformer</a> </li> <li> <a href="#blt">BLT</a> </li> </ul> <div> <a href="#a-world-of-improvements">A World of Improvements</a> </div> <div> <a href="#tradeoffs-of-ssms-and-transformers">Tradeoffs of SSMs and Transformers</a> </div> <ul> <li> <a href="#noisy-data">Noisy data</a> </li> <li> <a href="#ssms-as-compressive-models">SSMs as compressive models</a> </li> </ul> <div> <a href="#the-future">The Future</a> </div> </nav> </d-contents> <div> <p>This post is part of a two-part series.</p> <ol> <li>H-Nets: the Past</li> <li><a href="/blog/2025/hnet-future/">H-Nets: the Future</a></li> </ol> <p>The <a href="https://arxiv.org/abs/2507.07955" rel="external nofollow noopener" target="_blank">H-Net</a> model has been a dream of mine for years. I’ve been fortunate enough to be able to work with my student <a href="https://sukjunhwang.github.io/" rel="external nofollow noopener" target="_blank">Sukjun Hwang</a> who made the technical breakthroughs behind this model, solving (or at least making serious progress towards) what I consider to be a very difficult but foundational problem for deep learning.</p> <p>In this post, I provide an informal personal recounting of the motivation and history of this project, providing various context and discussion that wouldn’t make sense in a paper. This post is really just for fun – I’ve always found it interesting to read about the windy history of research instead of just the streamlined final result, and I felt like telling this story.</p> <p>In the next post <a href="#hnet-the-future">H-Nets (The Future)</a>, I’ll explain why I think this model is so important and a variety of potential downstream implications.</p> <h2 id="hierarchy-is-everywhere">Hierarchy is Everywhere</h2> <p>The idea of hierarchy has always resonated with me. Perhaps its comes from my penchant for discrete math and roots in competitive programming, where I spent all day working with algorithms on trees, the canonical hierarchical structure. Perhaps it reflects the way I tend to think; I structure almost everything hierarchically, for example using bulleted outlines for everything to a perhaps excessive degree (I’d write papers in outline format if I could!).</p> <p>At some point early in my PhD, when I wasn’t doing much productive work, I took an online class for fun on <a href="https://www.coursera.org/learn/learning-how-to-learn" rel="external nofollow noopener" target="_blank">Learning How to Learn</a>. I think this is where I came across the concept of <a href="https://en.wikipedia.org/wiki/Chunking_(psychology)" rel="external nofollow noopener" target="_blank">chunking</a> in human cognition, which really resonated with me and felt fundamental to intelligence. For example, our processing is strongly hierarchical: language is parsed into words, phrases, clauses, sentences, and beyond; perception is organized into objects and events; tasks are decomposed into subtasks and goals. Raw streams of thought are chunked into <em>abstractions</em> and <em>ideas</em>. The <em>chunking</em> concept seems really important to me, and later became adopted for this project’s terminology.</p> <h2 id="hierarchical-rnns">Hierarchical RNNs</h2> <p>From the very beginning of my work on sequence models, I was drawn to hierarchical models.</p> <p>My first exposure to sequence models came during an internship in 2019 at DeepMind under the amazing [Caglar Gulcehre] and [Nando de Freitas]. I started thinking about RNNs with help from Caglar, who was an encyclopedia of classical sequence models (e.g. he was on the original <a href="https://arxiv.org/abs/1412.3555" rel="external nofollow noopener" target="_blank">GRU</a> paper <d-cite key="chung2014empirical"></d-cite>) and pointed me to a lot of interesting ideas.</p> <p>I was particularly interested in the notion of improving long-range dependencies through hierarchies. This had been attempted in many flavors of RNNs, such as the Clockwork RNN <d-cite key="koutnik2014clockwork"></d-cite>, Hierarchical Multiscale RNN <d-cite key="chung2017hierarchical"></d-cite>, and Dilated RNN <d-cite key="chang2017dilated"></d-cite>. I played around with tons of ideas on incorporating hierarchies into RNNs; I particularly liked the idea of the <a href="https://arxiv.org/abs/1810.09536" rel="external nofollow noopener" target="_blank">Ordered Neuron LSTM</a> (ICLR 2019 best paper!) <d-cite key="shen2019ordered"></d-cite>, which introduced a clever mechanism to incorporate an implicit hierarchy in the forget/input gates of an LSTM. My <a href="https://arxiv.org/abs/1910.09890" rel="external nofollow noopener" target="_blank">first ever paper on sequence models</a> <d-cite key="gu2020improving"></d-cite> was heavily inspired by this paper (as well as by <a href="https://arxiv.org/abs/1804.11188" rel="external nofollow noopener" target="_blank">Chrono LSTM</a> <d-cite key="tallec2018can"></d-cite>, which inspired me to think of RNNs as continuous systems and led to a lot of my work on state space models – but that’s another story).</p> <h2 id="s4-and-sashimi">S4 and SaShiMi</h2> <p>After DeepMind, my research switched completely to sequence models<d-footnote>By the way, this happened in the 5th year of my PhD. I always tell junior PhD students that it's never too late and to focus on your fundamentals first!</d-footnote>, and I started developing state space models from <a href="https://arxiv.org/abs/2008.07669" rel="external nofollow noopener" target="_blank">HIPPO</a> <d-cite key="gu2020hippo"></d-cite> to <a href="https://arxiv.org/abs/2110.13985" rel="external nofollow noopener" target="_blank">LSSL</a> <d-cite key="gu2021combining"></d-cite> to <a href="https://arxiv.org/abs/2111.00396" rel="external nofollow noopener" target="_blank">S4</a> <d-cite key="gu2022efficiently"></d-cite>, which was the culmination of my PhD. A little known fact (I’m guessing) about the S4 paper is that I actually introduced a hierarchical architecture in one of the experiments!</p> <h3 id="autoregressive-u-nets-for-image-modeling">Autoregressive U-Nets for image modeling</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/s4_cifar-480.webp 480w,/assets/img/2025-07-11-hnet/s4_cifar-800.webp 800w,/assets/img/2025-07-11-hnet/s4_cifar-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/s4_cifar.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>In this paper, we tested S4’s autoregressive modeling ability on a variety of distributions: on the left is the CIFAR-10 density estimation problem, and on the right is language modeling on WikiText-103 (at the time a popular dataset, but far too small scale now).</p> <p>To improve the pixel modeling problem performance, I actually introduced an <em>autoregressive U-Net</em> structure that had two stages of downsampling. The overall structure of this model, such as the fixed-width pooling and how to preserve causality for the autoregressive sampling, is very similar to a bunch of models that have since been used for language (such as Hourglass Transformer, <a href="https://arxiv.org/abs/2305.07185" rel="external nofollow noopener" target="_blank">MegaByte</a> <d-cite key="yu2023megabyte"></d-cite>, <a href="https://arxiv.org/abs/2406.02657" rel="external nofollow noopener" target="_blank">Block Transformer</a> <d-cite key="ho2024block"></d-cite>, and a few others).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/s4_cifar_appendix-480.webp 480w,/assets/img/2025-07-11-hnet/s4_cifar_appendix-800.webp 800w,/assets/img/2025-07-11-hnet/s4_cifar_appendix-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/s4_cifar_appendix.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">I just realized that I never mentioned this detail anywhere in the main body, which seems like a big oversight. Oops.</figcaption> </figure> <p>As far as I’m aware, this paper (concurrently with <a href="https://arxiv.org/abs/2110.13711" rel="external nofollow noopener" target="_blank">Hourglass Transformer</a> <d-cite key="nawrot2022hierarchical"></d-cite>, submitted to arXiv just 5 days apart and with nearly identical architectures!) might have been the first to actually use an autoregressive U-Net?<d-footnote>On 1D sequences specifically; <a href="https://arxiv.org/abs/1701.05517" rel="external nofollow noopener" target="_blank">PixelCNN++</a> <d-cite key="salimans2017pixelcnn++"></d-cite> did something similar on 2D structure, which was the motivation for my architecture.</d-footnote> Although it’s not particularly complicated, so I wouldn’t be surprised if there were some earlier ones I missed.</p> <h3 id="u-nets-dont-work-for-language">U-Nets don't work for language</h3> <p>Something not reported in the paper, though, was that I tried the same backbone on the WikiText-103 language modeling experiments as well. I really wanted it to work, since I felt like hierarchy should be important! But no matter what I did, the hierarchical version was always <em>noticeably worse</em> than the isotropic backbone for language modeling.</p> <p>I eventually gave up on this, and I think it formed the basis for some of my intuition around language modeling. In particular, I realized that fixed-width pooling just didn’t make sense for language. (And moreover, I realized that this is essentially the same as convolutions, or at least has the same inductive bias, and this helped form the basis of my hypothesis about how convolutions don’t work for language modeling and more general “discrete data” that has variable spacing. See this part of my <a href="/blog/2025/tradeoffs/#a-hypothetical-litmus-test">Tradeoffs post</a> for a bit more discussion.)</p> <p>To be honest, I don’t really understand how so many papers on this U-Net-like strategy have been published for language modeling. I’m pretty skeptical that they work at all, as has also been shown in ablations by follow-up works on byte-level language modeling like <a href="https://arxiv.org/abs/2404.14408" rel="external nofollow noopener" target="_blank">SpaceByte</a> <d-cite key="slagle2024spacebyte"></d-cite> and <a href="https://arxiv.org/abs/2412.09871" rel="external nofollow noopener" target="_blank">BLT</a> <d-cite key="pagnoni2024byte"></d-cite>. I guess one major difference is that all of these papers were using Transformers, which is much better for language than S4, but I still don’t think it really makes sense 🤷.</p> <h3 id="but-they-work-great-for-audio">But they work great for audio!</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/sashimi-480.webp 480w,/assets/img/2025-07-11-hnet/sashimi-800.webp 800w,/assets/img/2025-07-11-hnet/sashimi-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/sashimi.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Instead, I realized that S4 and U-Nets (and convolutions in general) have a great inductive bias for data that has an underlying notion of uniform sampling rate, namely <strong>perceptual modalities</strong> like audio, images, and video. So <a href="https://www.linkedin.com/in/krandiash/" rel="external nofollow noopener" target="_blank">Karan</a> took this autoregressive U-Net backbone with S4 layers and applied it to modeling/generating raw audio waveforms, where <a href="https://arxiv.org/abs/2202.09729" rel="external nofollow noopener" target="_blank">it worked really well</a> <d-cite key="goel2022raw"></d-cite>!<d-footnote> I'm still proud of the method name and title, my most important contribution to this paper 😁</d-footnote></p> <h2 id="a-differentiable-chunking-mechanism">A Differentiable Chunking Mechanism?</h2> <p>Around 2022-2023, I was idly thinking about hierarchies in the back of my mind, and the way I conceptualized the goal was something like this.</p> <h3 id="attention-as-a-primitive">Attention as a primitive</h3> <p>To me the self-attention mechanism could be phrased as: A simple module that captures the “primitive” of forming <em>dense connections</em> and building <em>functions on sets</em>. What makes it powerful is that it feels simple and foundational; capturing some fundamental transformation in a simple differentiable way that allows it to be scaled.</p> <p>My research is always after these <strong>primitives</strong>: lower-level building blocks that capture fundamental properties and transformations, and can be flexibly applied and scaled. My work on state space models, for example, is really about fleshing out the primitive of <strong>recurrence</strong>, which I also do view as being a fundamental property of the world. (It’s probably not a very well-known fact that my academic job talk was not about SSMs per se; it was called <em>New Structured Primitives for Machine Learning</em>!)</p> <h3 id="chunking-as-a-primitive">Chunking as a primitive</h3> <p>I thought that <em>chunking</em> was another such fundamental primitive. I thought: would it be possible to invent a simple differentiable building block that encapsulated the idea of chunking? Based on my experience with language modeling, and my overall priors about the world, I felt like this would be an incredibly powerful module that would allow models to organize raw data into more meaningful units. Surely this was a more appropriate way of modeling language and much more!</p> <h3 id="tokenization-as-a-case-study">Tokenization as a case study</h3> <p>Back then, I had already formulated tokenization as a major problem that I wanted to solve. The first reason is, as I explained in my [<a href="/blog/2025/tradeoffs/#should-we-get-rid-of-tokenization">previous blog</a>], an appeal to aesthetics and generality, which to me felt important enough. But the more specific reason was that I felt that the proper way to solve tokenization would be through creating a <em>differentiable chunking mechanism</em>, which would be so much more powerful. This is still the way that I like to pitch the problem now, as some researchers that have talked to me directly might know from the way I hinted at the H-Net project over the last few months.</p> <blockquote> <p>Overcoming tokenization is <strong>not about tokenizers</strong>, but about <strong>learning abstractions</strong>. Discovering a tool that can do this will unlock new capabilities.</p> </blockquote> <h3 id="stuck">Stuck.</h3> <p>At this point, tokenization and chunking became one of my personal “holy grail” problems. But how can one create such a differentiable chunking primitive? Grouping discrete units of data together is, of course, a discrete selection problem, which is generally very hard for differentiable optimization. Unfortunately, <strong>I had absolutely no idea how to do this</strong>. So this was always just an idle thought in the back of my head, and I never actively worked on it.</p> <h2 id="information-based-chunking">Information-based Chunking</h2> <p>In 2024, I started idly thinking about this again; maybe partly motivated by <a href="http://cartesia.ai/" rel="external nofollow noopener" target="_blank">Cartesia</a>’s focus on audio, where it seemed like differentiable chunking could be very useful.</p> <h3 id="total-information-content-as-a-chunking-strategy">Total information content as a chunking strategy</h3> <p>I finally had an idea for how to do this: I still didn’t know how to make this process differentiable, but at the very least, perhaps we could come up with some smart general principles for what chunks should look like. It seemed like the key for a chunk to be “meaningful” is that it should have a certain amount of “information” in it. And there’s an easy proxy to create such constant-information chunks: Simply train a neural network to model the information content of the data (which can be read off of the conditional distributions of a standard autoregressive model, of course) and use that to segment the data, by grouping tokens together until the total negative log-likelihood of that chunk overflowed some threshold. This intuitively had a number of desirable properties, such as</p> <ul> <li>if there were a lot of low-information tokens that are very easy to predict, then there probably isn’t valuable meaning to them, so they should all be grouped together;</li> <li>if the model is surprised by the next token (such as the beginning of a word, which generally has higher entropy and intrinsic information), then the model would be forced to draw a boundary and start the next chunk, which ideally represented a new unit of meaning.</li> </ul> <p>(Fast forwarding a bit: in H-Net, we don’t <em>completely</em> understand where and why it decides to draw chunk boundaries, but we did notice a connection to this uncertainty principle; it tends to draw boundaries when surprised. But that’s the subject for a future post.)</p> <h3 id="the-project-begins">The project begins</h3> <p>About a year ago, in summer 2024, I gave a research talk (an early version of my [<a href="/blog/2025/tradeoffs/">Tradeoffs blog post</a>]) to my academic lab at CMU and highlighted some key problems and approaches that I thought could be important. Solving tokenization and finding a way to create hierarchical models that fit the natural information of the data was one such problem, and I pitched the above approach as a concrete direction to get started.</p> <p>Some students got interested and started thinking about this. I was still very, very interested in the above approach about information-based chunking; <a href="https://www.linkedin.com/in/ricardobuitrago/" rel="external nofollow noopener" target="_blank">Ricardo</a> explored it a little bit but didn’t get too far as he started working on another project on <a href="https://goombalab.github.io/blog/2025/improving-length-generalization/">length generalization in recurrent models</a> <d-cite key="buitrago2025understanding"></d-cite> (I’m also very fond of this result!). I kept trying to get Sukjun to try this approach as well, which I was convinced was a good idea…</p> <h2 id="differentiable-selection-with-modern-techniques">Differentiable Selection with Modern Techniques</h2> <p>Fortunately, Sukjun refused to listen to me because he had a much better idea! (A recurring theme in this project…)</p> <p>He wanted to try something loosely inspired by mixture-of-experts (MoE), the idea being that MoE (where each token gets “routed” to a fixed set of $k$ “experts”) is essentially a discrete selection problem like the one we want to solve.</p> <p>The main advantage of this approach is that it provides some hope for building a <em>differentiable</em> chunking strategy in an end-to-end model, unlike my information-based heuristic which would require training a separate proxy model first. At the time, I actually basically didn’t know anything at all how MoE worked, so I left Sukjun to his own devices for a long time, and he got the main ideas working relatively quickly. But there were a lot of really confusing training behaviors and instabilities, so he spent a long time building intuition and slowly improving the model.</p> <p>Incidentally, it’s kind of interesting to me how obvious in hindsight, but not in foresight, the main idea is. As this project developed, and I told a bunch of people about it, their reaction usually went from “this differentiable selection problem seems impossible” to “oh yeah that might work” as soon as I mentioned the connection to MoE being another variant of a discrete-selection problem.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/whiteboard_1-480.webp 480w,/assets/img/2025-07-11-hnet/whiteboard_1-800.webp 800w,/assets/img/2025-07-11-hnet/whiteboard_1-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/whiteboard_1.jpg" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/whiteboard_2-480.webp 480w,/assets/img/2025-07-11-hnet/whiteboard_2-800.webp 800w,/assets/img/2025-07-11-hnet/whiteboard_2-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/whiteboard_2.jpg" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Found some random whiteboard pictures from late 2024. Looks like on the left we were trying to figure out how to improve signal propagation into the router weights, including considering tricks like norm layers, straight-through estimator, and Gumbel noise. On the right we had just added the <i>per-network norms</i> idea from the paper and also had to properly rescale the initialization of each layer accordingly to balance (I just realized we might have forgotten to report this in the paper; there were <i>so many details</i> to get right, although all motivated by first principles). </div> <h2 id="discovering-prior-and-concurrent-works">Discovering Prior and Concurrent Works</h2> <p>When we started this project, we hadn’t done a very serious literature search attempt because there are incredibly few papers on this topic – I guess it’s a pretty hard problem after all. Over the course of the project, we discovered two related works that were most directly related, and I expect we’ll get plenty of questions about how they compare.</p> <h3 id="hourglass-and-dynamic-pooling-transformer">Hourglass and Dynamic Pooling Transformer</h3> <p>Around late October 2024, we discovered the <a href="https://arxiv.org/abs/2211.09761" rel="external nofollow noopener" target="_blank">Dynamic Pooling Transformer (DPT)</a> <d-cite key="nawrot2023efficient"></d-cite> (and its prior work, the Hourglass Transformer, which introduced an autoregressive U-Net structure concurrently with S4/SaShiMi). To the best of our knowledge, the DPT is the first, and I think essentially only, prior attempt at building an <strong>end-to-end hierarchical autoregressive model with dynamic chunking</strong>. The overall network structure was a similar autoregressive U-Net as Hourglass, the main difference being the incorporation of a binary-valued <em>boundary predictor</em> that tries to learn where to chunk the data.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/hourglass-480.webp 480w,/assets/img/2025-07-11-hnet/hourglass-800.webp 800w,/assets/img/2025-07-11-hnet/hourglass-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/hourglass.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">The Hourglass Transformer</figcaption> </figure> <p>Their motivation for how to overcome the discrete-choice problem was delegating to stochastic reparametrization techniques, namely the Gumbel-softmax trick <d-cite key="maddison2017concrete"></d-cite> <d-cite key="jang2017categorical"></d-cite>. In their paper, this fully end-to-end version didn’t seem to work too well; it had stability issues and underperformed their alternative variants that relied on more heuristics and supervision. Ultimately, I guess that DPT attempted to tackle this problem somewhat prematurely and important ideas weren’t available yet (for example, the most popular <a href="https://arxiv.org/abs/2101.03961" rel="external nofollow noopener" target="_blank">Switch Transformer</a> MoE method <d-cite key="fedus2022switch"></d-cite> was pretty new and perhaps not as established yet). But I think this paper deserves more credit for at least making a real attempt at this problem!</p> <p>Actually, before we found this paper we had tried many variations of Gumbel noise already; I’m rather fond of the Gumbel-softmax trick myself and kept trying to get Sukjun to incorporate it. But it never seemed to help empirically 🥲.</p> <details><summary>A missed naming opportunity</summary> <p>Just for fun, I’ll mention an earlier working name for the model I considered.</p> <p>I think Hourglass is an aesthetically pleasing name, and also elegantly describes the characteristic shape of the architecture; it’s essentially equivalent to a U-Net, but refers to the actual tensor shapes (gradually shrinking and then expanding the sequence, like an hourglass figure) instead of the abstract downsampling/upsampling flowchart.</p> <p>I thought about calling our model the <strong>Hourglass Network</strong> (shortened to H-Net), and the inner dynamic chunking module the <strong>TickTok</strong> layer. I really liked this name because there are several layers of meaning to it:</p> <ol> <li>Hourglass still refers to the shape of the hierarchical network. (Calling it “Network” also differentiated from the Hourglass Transformer, I suppose, since one of our important details was using SSMs in the outer layers.)</li> <li>The network structure could be viewed as <em>multi-rate sequence modeling</em> involving modalities or streams of data that <strong>tick</strong> at different rates, such as <em>characters vs. words</em>, or <em>audio vs. phonemes</em>. The <strong>Tick</strong>Tok layer would be the interface between these modalities.</li> <li>The network could also be viewed as performing a form of dynamic <strong>tok</strong>enization that compresses contiguous inputs just as tokenizers do. The Tick<strong>Tok</strong> layer would again be the mechanism that performs this compression. (<em>Dynamic tokenization</em>, instead of dynamic chunking, was also the working name for this project for a long time.)</li> <li>Finally, there’s a <strong>time</strong>-related theme to all of it: <em>Hourglass</em> Networks would be defined as models that have <em>temporally-dynamic</em> downsampling rates, where the core mechanism is the <em>“tick tock”</em> layer.</li> </ol> <p>Unfortunately, I was a bit concerned about the name “Hourglass” being confused for parallel lineages of work; it’s also been used by plenty of other <a href="https://arxiv.org/abs/1603.06937" rel="external nofollow noopener" target="_blank">unrelated</a> <a href="https://arxiv.org/abs/2401.11605" rel="external nofollow noopener" target="_blank">models</a>. “TickTok” might also have been a little cheesy; and the TikTok name is also of course a well-recognized brand that might be confusing, and has also already been used by a <a href="https://github.com/openai/tiktoken" rel="external nofollow noopener" target="_blank">very popular tokenizer</a>. So we didn’t go with it. Alas 🥲</p> <p>(I still liked the H-Net name, so we kept it and later “backronymed” it to Hierarchical Network. In my head I still like the name H-Net for this Hourglass connection though.)</p> </details> <h3 id="blt">BLT</h3> <p>By December, we had made a lot of progress and pretty much had the main architecture done (in particular, Sukjun had come up with the <em>smoothing module</em> which at the time we were calling the “EMA detokenizer”; as we show in the paper’s ablations, this was one of the most important new techniques introduced).</p> <p>At this point, the <a href="https://arxiv.org/abs/2412.09871" rel="external nofollow noopener" target="_blank">Byte Latent Transformer (BLT)</a> <d-cite key="pagnoni2024byte"></d-cite> paper came out, which made a big splash for claiming to solve tokenization end-to-end, through a similar hierarchical architecture using an entropy-based segmentation rule. (Actually, DPT above already proposed similar entropy heuristics, but didn’t execute it as well.) I think the terminology is a little confusing because they indeed built a model operating “end-to-end” on bytes, but to me, the crux of the problem is <em>learning the dynamic boundaries</em> jointly with the model itself. This is not possible (at least not obviously) with the entropy heuristic and is the main reason why we didn’t explore this approach. In the H-Net paper, we specifically use “end-to-end” to refer to this stronger definition. Still, it was gratifying to see that my idea to use information-based chunking heuristics does (somewhat) work!</p> <details><summary>A deeper dive into this approach</summary> <p>There is one major difference between the <a href="#total-information-content-as-a-chunking-strategy">original idea I had</a> and what BLT did. Since I’m not going to work on this approach, I might as well put it here.</p> <p>In my idea, although I also think of it as an “entropy-based approach”, the actual quantity used to determine chunk boundaries is the <em>information content</em> or negative log-likelihood of the next token. In BLT, the quantity used is the <em>conditional entropy</em> $H(x_t | x_0, \ldots, x_{t-1})$.</p> <p>The intuition in both is that segmentations should happen if the model is “surprised” by the next token. But surprise is better measured by the former quantity, not the latter. A concrete example is any conditional distribution that puts most of its mass on one vocab word $w$; this conditional distribution would have very low entropy and so the conditional entropy heuristic would never create a new chunk. But in the event that the actual token that appears is a different word $v \neq w$, the model should be <em>very</em> surprised and draw a boundary in the rare case this happens. The negative log-likelihood captures this actual information content.</p> <p>I’m a little confused by why both DPT and BLT used the conditional entropy instead. Maybe I’m missing something, or for some reason empirically it just works better?</p> </details> <h2 id="a-world-of-improvements">A World of Improvements</h2> <p>I think the architecture has been relatively stable since early 2025, but we spent a long time trying to understand and simplify every part of it. For example (this is just a small subset),</p> <ul> <li> <strong>Architecture components</strong>: our final architecture included post-norm layers at the end of every sub-network, as well as linear projections on the residual connection. We spent a long time trying to remove these since I felt like they were non-standard techniques (most U-Nets don’t have these) that complicated the model. But in the end, they seem very useful—maybe essential—and we kept them.</li> <li> <strong>Sparsity auxiliary loss</strong>: Our auxiliary loss targets a specific down-sampling ratio (Section 2.3 of the paper). This seems a little artificial to me and introduces an annoying new hyperparameter (thankfully, the only one!). I felt like it would be cleaner to simply impose a “sparsity loss” that encouraged higher compression rates (it would be counter-balanced by the main loss function which encourages more compute, hence lower compression rates). We found some things that sort of worked but it didn’t seem as consistent, so for this version of the H-Net we kept the targeted loss.</li> <li> <strong>Chunking mechanisms</strong>: We tried so many different variations of the routing module, upsampling step, downsampling step, smoothing module, and every other component. Sukjun’s PowerPoint deck of ideas and variations has hundreds of slides, and we were only able to report a very small subset of ablations in the paper of things we did.</li> <li> <strong>Layer allocation</strong>: Normal LLM scaling laws might be concerned with how to scale the width and depth of the model as the parameter count grows. But here, there are so many more choices for how many layers to put in each sub-network and how wide to make them and so on. Beyond that, the question of which layers to use (e.g. Transformer vs. Mamba) in each network is also not obvious, and required tons of experiments to understand (and I’m still not sure we have a completely clear grasp of how they predictably affect performance).</li> </ul> <p>Although our final (current) design has a lot of moving parts, they all had concrete motivations, and are as simple as we could make it without sacrificing stability or performance.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/tuning-480.webp 480w,/assets/img/2025-07-11-hnet/tuning-800.webp 800w,/assets/img/2025-07-11-hnet/tuning-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/tuning.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">A random slide from the deck of ideas involving multiple residual connections and extra stages/sub-networks, which remained as flags in the internal code for a long time.</figcaption> </figure> <p>I haven’t been able to run experiments personally in a while, and it was like watching an artist at work to see Sukjun improve the architecture steadily over time with multiple creative and essential ideas – if it isn’t clear, he has by far the best intuition for everything related to H-Nets.</p> <p>I have to say that this was one of the most difficult empirical projects I’ve witnessed (and I think I’m somewhat decent at creating architectures 👀). Normally when tuning models, one hopes that different axes of variation act somewhat independently so they can be ablated in isolation and we can perform a “coordinate descent in design space”. But somehow for this architecture, it felt like there were 12 different axes that were all critical and that <em>all had to interact together in exactly the right way</em>. There were so many times when we thought that option “A” was better than “B”, before changing some other design decisions and flip-flopping to B, before changing even more things and going back to A. And this happened with every axis of variation. Even after we had all the main ingredients, it was really difficult to get them to interact together seamlessly. The main driving force here was Sukjun’s intuition and persistence.</p> <h2 id="tradeoffs-of-ssms-and-transformers">Tradeoffs of SSMs and Transformers</h2> <p>In my previous blog post, I argued that we as a community should care about getting rid of tokenization. I hope the H-Net has done that, or at least shown the first step that it’s possible. Aside from that, there are a couple of points in the previous post that I’ll specifically call back to.</p> <h3 id="noisy-data">Noisy data</h3> <p>I proposed [<a href="/blog/2025/tradeoffs/#a-hypothetical-litmus-test">a hypothetical litmus test</a>] involving sequences padded with information-less noise tokens. This was a thought experiment that partially motivated why I was so interested in hierarchical models. The idea is that one should be able to train some lightweight encoder and decoder networks that perform the compression of each chunk, folding each contiguous run of noise tokens into the previous meaningful token. This should be able to compress and strip away the noise tokens before feeding it to a main network that operates just over the meaningful tokens.</p> <p>Can the H-Net actually solve this in practice? I don’t know, maybe some more work would need to be done. I was more interested in the litmus test as a thought experiment to guide architecture design, not necessarily as an actual synthetic task. I did hypothesize though that something that could theoretically solve the litmus test might be better at working with noisier data, but I’d say I don’t have particularly high confidence in this hypothesis (I really don’t know).</p> <h3 id="ssms-as-compressive-models">SSMs as compressive models</h3> <p>Finally, let me show perhaps my favorite experiment from the paper, even though this is buried somewhere late in the ablations because it’s subtle.</p> <p>In the previous post, I asked the question: [<a href="/blog/2025/tradeoffs/#compression-bug-feature">Is compression a bug, or a feature?</a>] And I floated the idea that perhaps SSMs had hidden strengths due to their compressive abilities.</p> <p>The more obvious piece of evidence I gave for this was comparing the inductive bias of SSMs and Transformers, for example, contrasting these two facts:</p> <ol> <li>Transformers and SSMs have similar performance on tokenized language</li> <li>Transformers seriously underperform SSMs on untokenized language</li> </ol> <p>My intuitive explanation was that on high-resolution data without meaning (such as characters), attention is a poor inductive bias, and understanding the data requires compressing it. Ablations in the H-Net paper corroborate this: <strong>any parts of the model interacting directly with byte-level input resolution strongly benefit from SSM layers</strong>.</p> <p>This raises a natural question though: is the importance of Mamba layers because</p> <ol> <li>they are better at <strong>processing fine-grained byte inputs</strong>, as we already knew?</li> <li>or because they are better for <strong>compressing information into the next stage</strong>, even if given coarser inputs?</li> </ol> <p>We can disentangle these two hypotheses by simply applying an H-Net on data that’s not byte-level. After all, it’s just a generic sequence model architecture that can be applied on any data! In particular, let’s apply it to data that’s already BPE-tokenized.</p> <ol> <li>If the first hypothesis holds, then we would expect Mamba to not help in the encoder/decoder, since (as mentioned above) they have similar performance to Transformers on standard tokenized language modeling.</li> <li>If the second hypothesis holds, then we would expect that encoders/decoders using some Mamba layers to be better than pure Transformer layers.</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/abl_enc_dec_combination_BPE-480.webp 480w,/assets/img/2025-07-11-hnet/abl_enc_dec_combination_BPE-800.webp 800w,/assets/img/2025-07-11-hnet/abl_enc_dec_combination_BPE-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/abl_enc_dec_combination_BPE.png" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">A 1-stage H-Net trained on top of standard BPE-tokenized inputs, with T2M2-M2T2 for example denoting 2 Transformer layers and 2 Mamba layers in the encoder (and the reverse in the decoder). Note that Transformer layers are 2x the size of Mamba layers here, so everything is parameter/compute matched.</figcaption> </figure> <p>This figure shows that it’s indeed the second hypothesis that holds. This is really interesting and to me provides serious evidence that SSMs really are doing something interesting that other models can’t do, and that <strong>perhaps compression <em>is</em> fundamental to intelligence</strong>.</p> <h2 id="the-future">The Future</h2> <p>There’s a ton of stuff we could do and ideas that we have that we left on the table. A bunch of questions are pointed out in the Discussions section of the paper, and in my next post, although this is only a subset of the wide range of follow-up directions that I think will be interesting to work on.</p> <p>One question that I expect we’ll get is: do H-Nets <strong>actually scale better</strong>? In the paper, we showed training loss curves, where they display a striking trend of seeming to scale better with more data. We use these as proxies for a qualitative assessment of their scaling behavior, which I do believe is valuable (a justification is in the Discussion section of the paper). I also actually do believe that H-Nets will shift the scaling law curve in a non-trivial way. However, what we did aren’t formal scaling laws.</p> <p>Why didn’t we do those? Well, I guess the main reason is limited compute and more so the <a href="#a-world-of-improvements">sheer difficulty</a> of developing this model, which is where all our resources were invested. At no point did it seem worth completely freezing the architecture to run out expensive formal scaling laws, when I think we were able to get an intuitive understanding of their behavior from our proxy protocol; and moreover, when it always seems like there are core questions we don’t understand and low-hanging improvements to make to the model.</p> <div style="max-width: 600px; margin: 0 auto; text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-11-hnet/bpb_curve_xl_hnet_white-480.webp 480w,/assets/img/2025-07-11-hnet/bpb_curve_xl_hnet_white-800.webp 800w,/assets/img/2025-07-11-hnet/bpb_curve_xl_hnet_white-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/2025-07-11-hnet/bpb_curve_xl_hnet_white.png" width="50%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="caption"> On a similar note, I realized we should have just ran this out for much more data to see if the gap widens 🤦🏻 <br> We didn't because we only ran things out enough to follow our protocols and provide signal to improving the model. </div> <p>We have a lot of ideas for where to go from here; I’ll touch on some of these in the <a href="/blog/2025/hnet-future/">next post</a>.</p> </div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/albert.bib"></d-bibliography> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Goomba AI Lab. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cloud.umami.is/script.js" data-website-id="340bca3c-b84e-462f-98dd-f4f4629b9751"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>